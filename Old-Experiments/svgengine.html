<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Chemical Graphics Engine - Showcase</title>
    <style>
        /* --- UI LAYOUT STYLES --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 20px;
            color: #333;
        }

        h1 {
            text-align: center;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            padding: 15px;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            font-size: 0.9rem;
            text-transform: uppercase;
            color: #777;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .canvas-container {
            height: 250px;
            width: 100%;
            background: #fff;
            position: relative;
            border: 1px dashed #eee;
            /* Visual guide bounds */
        }

        /* --- CHEMICAL ENGINE STYLES (REQUIRED) --- */
        .chem-svg {
            font-family: 'Arial', sans-serif;
            overflow: visible;
        }

        /* Layer Z-Index simulation via Group Order */
        .layer-bonds path {
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* Typography */
        .layer-atoms text {
            text-anchor: middle;
            dominant-baseline: central;
            font-weight: bold;
            fill: #000;
        }

        /* Atom Halo (Masking) */
        .atom-halo {
            stroke: #ffffff;
            stroke-width: 5px;
            stroke-linejoin: round;
            fill: none;
            opacity: 1;
        }

        /* Bond Styles */
        .bond-std {
            stroke: #111;
            stroke-width: 2px;
            fill: none;
        }

        .bond-wedge {
            fill: #111;
            stroke: none;
        }

        .bond-dash {
            stroke: #111;
            stroke-width: 2px;
            stroke-dasharray: 4, 3;
            fill: none;
        }

        .bond-wavy {
            stroke: #111;
            stroke-width: 2px;
            fill: none;
        }

        /* Electrons */
        .electron-dot {
            fill: #d00;
        }

        /* Arrows */
        .mech-arrow {
            stroke: #007bff;
            stroke-width: 1.5px;
            fill: none;
        }

        .reaction-arrow {
            stroke: #333;
            stroke-width: 2px;
            fill: none;
        }

        /* Labels */
        .chem-label {
            font-size: 12px;
            fill: #555;
            font-style: italic;
        }

        .charge-label {
            font-size: 10px;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <h1>SVG Chemical Engine Capabilities</h1>

    <div class="grid-container">
        <!-- 1. Bonds & Structure -->
        <div class="card">
            <div class="card-header">1. Bonds & Multiplicity</div>
            <div id="c1" class="canvas-container"></div>
        </div>

        <!-- 2. Stereochemistry -->
        <div class="card">
            <div class="card-header">2. Stereochemistry</div>
            <div id="c2" class="canvas-container"></div>
        </div>

        <!-- 3. Atoms & Typography -->
        <div class="card">
            <div class="card-header">3. Atoms, Isotopes & Groups</div>
            <div id="c3" class="canvas-container"></div>
        </div>

        <!-- 4. Charges & Electrons -->
        <div class="card">
            <div class="card-header">4. Charges & Lone Pairs</div>
            <div id="c4" class="canvas-container"></div>
        </div>

        <!-- 5. Mechanism Arrows -->
        <div class="card">
            <div class="card-header">5. Electron Pushing (Curved)</div>
            <div id="c5" class="canvas-container"></div>
        </div>

        <!-- 6. Reaction Arrows -->
        <div class="card">
            <div class="card-header">6. Reaction Conditions</div>
            <div id="c6" class="canvas-container"></div>
        </div>
    </div>

    <!-- ENGINE CODE -->
    <script>
        const NS = "http://www.w3.org/2000/svg";

        class ChemEngine {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.width = this.container.clientWidth;
                this.height = this.container.clientHeight;
                this.initSVG();
                this.defineMarkers();
            }

            initSVG() {
                this.svg = document.createElementNS(NS, "svg");
                this.svg.setAttribute("width", "100%");
                this.svg.setAttribute("height", "100%");
                this.svg.setAttribute("viewBox", `0 0 ${this.width} ${this.height}`);
                this.svg.classList.add("chem-svg");

                // Create Layers
                this.layers = {
                    defs: this.createGroup("defs"),
                    bonds: this.createGroup("layer-bonds"),
                    atoms: this.createGroup("layer-atoms"),
                    electrons: this.createGroup("layer-electrons"),
                    reaction: this.createGroup("layer-reaction"),
                    mech: this.createGroup("layer-mech"),
                    labels: this.createGroup("layer-labels")
                };

                // Append in Order
                Object.values(this.layers).forEach(l => {
                    if (l.tagName !== "defs") this.svg.appendChild(l);
                    else this.svg.prepend(l);
                });
                this.container.appendChild(this.svg);
            }

            createGroup(id) {
                const g = document.createElementNS(NS, (id === "defs" ? "defs" : "g"));
                g.setAttribute("class", id);
                return g;
            }

            defineMarkers() {
                const mk = (id, col, pathD, w = 10, h = 10, refX = 9) => {
                    const m = document.createElementNS(NS, "marker");
                    m.setAttribute("id", id);
                    m.setAttribute("markerWidth", w);
                    m.setAttribute("markerHeight", h);
                    m.setAttribute("refX", refX);
                    m.setAttribute("refY", 5);
                    m.setAttribute("orient", "auto");
                    const p = document.createElementNS(NS, "path");
                    p.setAttribute("d", pathD);
                    p.setAttribute("fill", col);
                    m.appendChild(p);
                    this.layers.defs.appendChild(m);
                };
                // Blue Mech Arrow
                mk("arrow-mech", "#007bff", "M0,0 L10,5 L0,10 L2,5 z");
                // Fishhook (Half)
                mk("arrow-fish", "#007bff", "M0,0 L10,5 L0,5 L2,3 z");
                // Black Reaction Arrow
                mk("arrow-rxn", "#333", "M0,0 L10,5 L0,10 L1,5 z");
                // Retro Arrow
                mk("arrow-retro", "#333", "M0,0 L10,5 L0,10 L1,5 z", 10, 10, 1); // Hollow logic handled in path usually, but simplifying here
            }

            // --- MATH ---
            vec(x1, y1, x2, y2) {
                const dx = x2 - x1,
                    dy = y2 - y1;
                return {
                    dx,
                    dy,
                    dist: Math.sqrt(dx * dx + dy * dy)
                };
            }
            norm(dx, dy) {
                const l = Math.sqrt(dx * dx + dy * dy);
                return {
                    x: -dy / l,
                    y: dx / l
                };
            }

            // --- CORE DRAWING ---

            drawAtom(symbol, x, y, opts = {}) {
                const g = document.createElementNS(NS, "g");
                g.setAttribute("transform", `translate(${x},${y})`);

                // Parse label for subscripts (Simple digits check)
                const parts = symbol.split(/(\d+)/).filter(Boolean);
                const text = document.createElementNS(NS, "text");
                const halo = document.createElementNS(NS, "text");
                halo.classList.add("atom-halo");

                // Font adjustment
                const fontSize = opts.fontSize || 16;
                text.setAttribute("font-size", fontSize);
                halo.setAttribute("font-size", fontSize);

                let content = "";
                parts.forEach(p => {
                    const ts = `<tspan dy="${!isNaN(p)?'4':'-4'}" font-size="${!isNaN(p)?'0.75em':'1em'}">${p}</tspan>`;
                    content += ts;
                });

                // Hacky baseline fix for first element
                content = content.replace('dy="-4"', 'dy="0"');

                text.innerHTML = content;
                halo.innerHTML = content;

                g.appendChild(halo);
                g.appendChild(text);

                // Charges
                if (opts.charge) {
                    const c = document.createElementNS(NS, "text");
                    c.textContent = opts.charge;
                    c.setAttribute("class", "charge-label");
                    c.setAttribute("x", 8);
                    c.setAttribute("y", -8);
                    c.setAttribute("fill", opts.chargeColor || "#000");
                    g.appendChild(c);
                }

                // Isotope
                if (opts.isotope) {
                    const i = document.createElementNS(NS, "text");
                    i.textContent = opts.isotope;
                    i.setAttribute("font-size", "10");
                    i.setAttribute("x", -10);
                    i.setAttribute("y", -6);
                    g.appendChild(i);
                }

                this.layers.atoms.appendChild(g);
            }

            drawBond(x1, y1, x2, y2, type = "single") {
                const path = document.createElementNS(NS, "path");
                const {
                    dx,
                    dy,
                    dist
                } = this.vec(x1, y1, x2, y2);
                const n = this.norm(dx, dy);
                const pad = 14; // Text padding

                // Shorten line to not hit text center
                const sx = x1 + (dx / dist) * pad,
                    sy = y1 + (dy / dist) * pad;
                const ex = x2 - (dx / dist) * pad,
                    ey = y2 - (dy / dist) * pad;

                let d = "";

                if (type === "single") {
                    path.classList.add("bond-std");
                    d = `M${sx},${sy} L${ex},${ey}`;
                } else if (type === "double") {
                    path.classList.add("bond-std");
                    const off = 3;
                    d = `M${sx + n.x*off},${sy + n.y*off} L${ex + n.x*off},${ey + n.y*off}
                         M${sx - n.x*off},${sy - n.y*off} L${ex - n.x*off},${ey - n.y*off}`;
                } else if (type === "triple") {
                    path.classList.add("bond-std");
                    const off = 4;
                    d = `M${sx},${sy} L${ex},${ey}
                         M${sx + n.x*off},${sy + n.y*off} L${ex + n.x*off},${ey + n.y*off}
                         M${sx - n.x*off},${sy - n.y*off} L${ex - n.x*off},${ey - n.y*off}`;
                } else if (type === "wedge") {
                    path.classList.add("bond-wedge");
                    const w = 5;
                    d = `M${sx},${sy} L${ex + n.x*w},${ey + n.y*w} L${ex - n.x*w},${ey - n.y*w} Z`;
                } else if (type === "dash") {
                    path.classList.add("bond-dash");
                    d = `M${sx},${sy} L${ex},${ey}`;
                } else if (type === "wavy") {
                    path.classList.add("bond-wavy");
                    // Simple ZigZag/Sine approximation
                    const steps = 6;
                    d = `M${sx},${sy}`;
                    for (let i = 1; i <= steps; i++) {
                        const t = i / steps;
                        const tx = sx + (ex - sx) * t;
                        const ty = sy + (ey - sy) * t;
                        const amp = (i % 2 === 0 ? 3 : -3);
                        d += ` L${tx + n.x*amp},${ty + n.y*amp}`;
                    }
                }

                path.setAttribute("d", d);
                this.layers.bonds.appendChild(path);
            }

            drawElectronPair(x, y, angle) {
                const g = document.createElementNS(NS, "g");
                const rad = angle * Math.PI / 180;
                const dist = 14;
                const sep = 2.5;

                const cx = x + Math.cos(rad) * dist;
                const cy = y + Math.sin(rad) * dist;
                const nx = -Math.sin(rad) * sep;
                const ny = Math.cos(rad) * sep;

                [1, -1].forEach(dir => {
                    const c = document.createElementNS(NS, "circle");
                    c.setAttribute("cx", cx + nx * dir);
                    c.setAttribute("cy", cy + ny * dir);
                    c.setAttribute("r", 1.5);
                    c.classList.add("electron-dot");
                    g.appendChild(c);
                });
                this.layers.electrons.appendChild(g);
            }

            drawCurvedArrow(x1, y1, x2, y2, type = "2e") {
                const path = document.createElementNS(NS, "path");
                const {
                    dx,
                    dy
                } = this.vec(x1, y1, x2, y2);
                const n = this.norm(dx, dy);

                const mx = (x1 + x2) / 2 + n.x * 30;
                const my = (y1 + y2) / 2 + n.y * 30;

                path.setAttribute("d", `M${x1},${y1} Q${mx},${my} ${x2},${y2}`);
                path.classList.add("mech-arrow");
                path.setAttribute("marker-end", type === "1e" ? "url(#arrow-fish)" : "url(#arrow-mech)");
                this.layers.mech.appendChild(path);
            }

            drawReactionArrow(x1, y1, x2, y2, type = "fwd", top = "", bot = "") {
                const g = document.createElementNS(NS, "g");

                if (type === "fwd") {
                    const p = document.createElementNS(NS, "path");
                    p.setAttribute("d", `M${x1},${y1} L${x2},${y2}`);
                    p.classList.add("reaction-arrow");
                    p.setAttribute("marker-end", "url(#arrow-rxn)");
                    g.appendChild(p);
                } else if (type === "eq") {
                    // Equilibrium (two half arrows)
                    const off = 4;
                    const p1 = document.createElementNS(NS, "path");
                    p1.setAttribute("d", `M${x1},${y1-off} L${x2},${y2-off}`);
                    p1.classList.add("reaction-arrow");
                    p1.style.markerEnd = "url(#arrow-rxn)"; // Simplified, ideally half-head

                    const p2 = document.createElementNS(NS, "path");
                    p2.setAttribute("d", `M${x2},${y1+off} L${x1},${y2+off}`);
                    p2.classList.add("reaction-arrow");
                    p2.style.markerEnd = "url(#arrow-rxn)";

                    g.appendChild(p1);
                    g.appendChild(p2);
                }

                // Text
                const mx = (x1 + x2) / 2;
                const my = (y1 + y2) / 2;

                if (top) {
                    const t = document.createElementNS(NS, "text");
                    t.textContent = top;
                    t.setAttribute("x", mx);
                    t.setAttribute("y", my - 10);
                    t.setAttribute("text-anchor", "middle");
                    t.setAttribute("font-size", "12");
                    g.appendChild(t);
                }
                if (bot) {
                    const t = document.createElementNS(NS, "text");
                    t.textContent = bot;
                    t.setAttribute("x", mx);
                    t.setAttribute("y", my + 15);
                    t.setAttribute("text-anchor", "middle");
                    t.setAttribute("font-size", "11");
                    t.setAttribute("fill", "#666");
                    g.appendChild(t);
                }

                this.layers.reaction.appendChild(g);
            }
        }

        // --- DEMONSTRATION LOGIC ---

        // 1. BONDS & STRUCTURE
        const c1 = new ChemEngine("c1");
        // Ethene
        c1.drawAtom("CH2", 50, 125);
        c1.drawAtom("CH2", 150, 125);
        c1.drawBond(50, 125, 150, 125, "double");
        // Acetylene
        c1.drawAtom("CH", 200, 125);
        c1.drawAtom("CH", 300, 125);
        c1.drawBond(200, 125, 300, 125, "triple");

        // 2. STEREOCHEMISTRY
        const c2 = new ChemEngine("c2");
        const center = {
            x: 175,
            y: 125
        };
        c2.drawAtom("C", center.x, center.y);
        c2.drawAtom("NH2", center.x, center.y - 60);
        c2.drawAtom("H", center.x, center.y + 60);
        c2.drawAtom("COOH", center.x + 60, center.y + 20); // Wedge
        c2.drawAtom("CH3", center.x - 60, center.y + 20); // Dash

        c2.drawBond(center.x, center.y, center.x, center.y - 60, "single");
        c2.drawBond(center.x, center.y, center.x, center.y + 60, "single");
        c2.drawBond(center.x, center.y, center.x + 60, center.y + 20, "wedge");
        c2.drawBond(center.x, center.y, center.x - 60, center.y + 20, "dash");

        // Wavy (Unknown stereo)
        c2.drawAtom("OH", 300, 125);
        c2.drawBond(center.x + 60, center.y + 20, 300, 125, "wavy");

        // 3. ATOMS & LABELS
        const c3 = new ChemEngine("c3");
        c3.drawAtom("H2O", 50, 100);
        c3.drawAtom("Ph", 120, 100); // Phenyl Group
        c3.drawAtom("OEt", 180, 100); // Ethyl Group

        // Isotope
        c3.drawAtom("C", 250, 100, {
            isotope: "13"
        });
        c3.drawAtom("H", 300, 100, {
            isotope: "2"
        }); // Deuterium

        // Metal Complex placeholder
        c3.drawAtom("Pd", 175, 180, {
            fontSize: 20
        });
        c3.drawAtom("Cl", 120, 180);
        c3.drawAtom("Cl", 230, 180);
        c3.drawBond(175, 180, 120, 180, "single");
        c3.drawBond(175, 180, 230, 180, "single");

        // 4. CHARGES & ELECTRONS
        const c4 = new ChemEngine("c4");
        // Carbocation
        c4.drawAtom("C", 80, 125, {
            charge: "⊕",
            chargeColor: "#d00"
        });
        c4.drawBond(80, 125, 40, 160, "single");
        c4.drawBond(80, 125, 40, 90, "single");
        c4.drawBond(80, 125, 120, 125, "single");

        // Carbanion with Lone Pair
        c4.drawAtom("C", 200, 125, {
            charge: "⊖",
            chargeColor: "#00d"
        });
        c4.drawBond(200, 125, 240, 160, "single");
        c4.drawElectronPair(200, 125, 270); // Top

        // Water lone pairs
        c4.drawAtom("O", 300, 125);
        c4.drawAtom("H", 280, 150);
        c4.drawAtom("H", 320, 150);
        c4.drawBond(300, 125, 280, 150, "single");
        c4.drawBond(300, 125, 320, 150, "single");
        c4.drawElectronPair(300, 125, 45);
        c4.drawElectronPair(300, 125, 135);

        // 5. MECHANISM
        const c5 = new ChemEngine("c5");
        // Nucleophilic Attack Setup
        c5.drawAtom("Nu", 50, 150, {
            charge: "-"
        });
        c5.drawElectronPair(50, 150, 0);

        c5.drawAtom("C", 150, 150);
        c5.drawAtom("O", 150, 80);
        c5.drawBond(150, 150, 150, 80, "double");
        c5.drawAtom("R", 120, 180);
        c5.drawAtom("R", 180, 180);
        c5.drawBond(150, 150, 120, 180, "single");
        c5.drawBond(150, 150, 180, 180, "single");

        // Arrow: Nu to C
        c5.drawCurvedArrow(65, 150, 140, 150, "2e");
        // Arrow: Bond to O
        c5.drawCurvedArrow(155, 115, 170, 80, "2e");

        // Radical Fishhook
        c5.drawAtom("Cl", 250, 150);
        c5.drawElectronPair(250, 150, 0); // Single dot in real engine, represented as pair here
        c5.drawAtom("CH4", 320, 150);
        c5.drawCurvedArrow(265, 150, 300, 150, "1e"); // Fishhook

        // 6. REACTION ARROWS
        const c6 = new ChemEngine("c6");

        // Standard Fwd
        c6.drawReactionArrow(50, 60, 200, 60, "fwd", "NaOH, H2O", "Reflux, 2h");

        // Equilibrium
        c6.drawReactionArrow(50, 150, 200, 150, "eq", "Ka = 10.5");

        // No Reaction (Visual hack with cross)
        c6.drawReactionArrow(50, 220, 150, 220, "fwd");
        // Manually drawing X over arrow
        const xg = document.createElementNS(NS, "g");
        const x1 = document.createElementNS(NS, "path");
        x1.setAttribute("d", "M90,210 L110,230");
        x1.setAttribute("stroke", "red");
        x1.setAttribute("stroke-width", "3");
        const x2 = document.createElementNS(NS, "path");
        x2.setAttribute("d", "M110,210 L90,230");
        x2.setAttribute("stroke", "red");
        x2.setAttribute("stroke-width", "3");
        xg.appendChild(x1);
        xg.appendChild(x2);
        c6.layers.reaction.appendChild(xg);
    </script>
</body>

</html>
